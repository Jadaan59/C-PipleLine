Gidon, Abbas, 318482940
# Analyzer Plugin Pipeline

## Overview

This project is a modular, extensible text-processing pipeline designed to dynamically load and chain plugins at runtime. Each plugin processes strings and forwards the results to the next stage. The system is built to handle graceful shutdowns using a sentinel string `<END>`.

### Creating Plugins

To create a new plugin, implement the SDK provided in `plugin_sdk.h`. The SDK defines the required functions and structures for integration:
- `plugin_init`: Initialize the plugin.
- `plugin_place_work`: Accept input for processing.
- `plugin_attach`: Attach the plugin to the pipeline.
- `plugin_wait_finished`: Wait for the plugin to finish processing.
- `plugin_fini`: Clean up resources.

Plugins should be compiled as shared libraries (`.so`) and placed in the `output/` directory. For example, a plugin named `uppercaser` should produce `output/uppercaser.so`.

## Project Structure

- `main.c` — Loads plugins (via `dlopen`), wires the pipeline, reads stdin, and coordinates shutdown.
- `plugins/` — All plugin code and common runtime:
  - `plugin_common.c`, `plugin_common.h` — Shared plugin runtime: queue/thread lifecycle, attach/forward, logging, sentinel handling.
  - `sync/monitor.c`, `sync/monitor.h` — Minimal monitor (mutex + condition + latched signal).
  - `sync/consumer_producer.c`, `sync/consumer_producer.h` — Bounded producer–consumer queue built on monitors.
  - `logger.c`, `uppercaser.c`, `rotator.c`, `flipper.c`, `expander.c`, `typewriter.c` — Example plugins.
- `build.sh` — Builds the main binary and all plugins into `output/`.
- `output/` — Build artifacts: `analyzer` and `*.so` plugins (created by the build script).

## Runtime Flow and Sync

1. `main.c` loads `output/<plugin>.so` for each name passed on the command line and resolves the standard plugin symbols (`plugin_init`, `plugin_place_work`, `plugin_attach`, `plugin_wait_finished`, `plugin_fini`).
2. Each plugin calls `common_plugin_init(...)`, which:
   - Creates a bounded queue (`consumer_producer_*`).
   - Starts a worker thread that repeatedly `get`s from the queue, runs the plugin `process_func`, and forwards the result to the next stage.
3. Producers (`plugin_place_work`) call `consumer_producer_put`, which blocks when the queue is full using the `not_full` monitor. Consumers block on `consumer_producer_get` using the `not_empty` monitor.
4. When `<END>` reaches `plugin_place_work`, the common layer does not enqueue it. Instead, it calls `consumer_producer_signal_finished`, which sets `finished=1` and signals all monitors. Each worker thread drains remaining items, then forwards a single `<END>` downstream after its queue is empty.
5. `main.c` waits for completion by calling each plugin’s `plugin_wait_finished` (joins the worker thread) and then `plugin_fini` to release resources.


### Build on Mac and Windows

To build the project, use the provided `Dockerfile` for a consistent GCC and toolchain environment.

#### For Mac users:

```sh
# Build the Docker image
docker build -t analyzer .

# Run the build inside the Docker container
docker run --rm -it  -v "$(pwd):/workspace" -w /workspace  analyzer bash
```

#### For Windows users:

```powershell
# Build the Docker image
docker build -t analyzer-pipeline .

# Run the build inside the Docker container
docker run --rm -it -v "${PWD}:/workspace" -w /workspace analyzer-pipeline bash
```

### Usage

```text
./output/analyzer <queue_size> <plugin1> ... <pluginN>
```

### Example

```sh
# Example with piped input
./build.sh

echo -e "hello\n<END>" | ./output/analyzer 20 uppercaser rotator logger
```

### Interactive Input

```sh
./output/analyzer <queue_size> <plugin1> ... <pluginN>
# Type your lines, press Enter after each
# When done, type:
<END>
```
